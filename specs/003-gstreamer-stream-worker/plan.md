# Implementation Plan: Stream Worker Implementation

**Branch**: `003-stream-worker` | **Date**: 2025-12-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-gstreamer-stream-worker/spec.md`

## Summary

Implement a GStreamer-based stream worker that pulls RTSP input from MediaMTX, processes audio through a remote STS Service via Socket.IO for real-time dubbing, and publishes the output back to MediaMTX via RTMP. The implementation extends the existing `StreamWorker` class with GStreamer pipeline integration, segment buffering (MP4 video, M4A audio), STS Socket.IO client (per spec 017 WebSocket Audio Fragment Protocol), A/V synchronization, circuit breaker resilience, and Prometheus metrics.

## Technical Context

**Language/Version**: Python 3.10.x (per constitution and monorepo spec)
**Primary Dependencies**:
- PyGObject (gi.repository) for GStreamer bindings
- GStreamer 1.x (gst-plugins-base, good, bad, ugly)
- python-socketio>=5.0 for Socket.IO AsyncClient (real-time STS communication)
- prometheus_client for metrics
- FastAPI (existing service framework)

**Storage**: Disk-based segment storage (MP4 video, M4A audio) in WORKER_SEGMENT_DIR; in-memory state for queues and circuit breaker
**Testing**: pytest with pytest-asyncio, pytest-cov (80% coverage gate)
**Target Platform**: Linux/Docker container on AWS EC2 (CPU-only)
**Project Type**: Monorepo service (apps/media-service)
**Performance Goals**:
- RTSP connection < 500ms latency
- A/V sync delta < 120ms steady-state
- STS round-trip < 8000ms timeout
**Constraints**:
- No GPU (CPU-only GStreamer pipeline)
- Video and audio codec-copy (no re-encode) - FLV demux to MP4/M4A segments
- 6-second segment buffer for both video and audio tracks (lower latency)
- MP4 format for video segments (disk storage)
- M4A format for audio segments (disk storage + STS transport via Socket.io)
- Socket.io for real-time STS communication (not HTTP REST)
**Scale/Scope**: Single worker per stream, horizontal scaling via orchestrator

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Principle I - Real-Time First**:
- [x] GStreamer pipeline handles continuous data flow
- [x] Audio chunking emits 6-second M4A fragments without blocking
- [x] Circuit breaker enables non-blocking fallback on STS failure

**Principle II - Testability Through Isolation**:
- [x] Mock patterns documented for GStreamer elements
- [x] Mock STS server for deterministic testing
- [x] Test fixture: `tests/fixtures/test-streams/1-min-nfl.mp4` (60s, H.264/AAC)

**Principle III - Spec-Driven Development**:
- [x] Parent spec: `specs/003-gstreamer-stream-worker.md`
- [x] Implementation spec: `specs/003-gstreamer-stream-worker/spec.md`
- [x] This plan documents all architectural decisions before implementation

**Principle IV - Observability & Debuggability**:
- [x] Prometheus metrics defined (fragments, fallbacks, RTT, sync delta)
- [x] Structured logging with streamId, fragmentId, batchNumber

**Principle V - Graceful Degradation**:
- [x] Circuit breaker protects against STS failures
- [x] Fallback to original audio when breaker open

**Principle VI - A/V Sync Discipline**:
- [x] Video passthrough preserves original timestamps
- [x] Audio PTS tracked relative to pipeline clock
- [x] av_offset_ns applied to both video and audio output

**Principle VII - Incremental Delivery**:
- [x] 5 phases: Pipeline -> Chunking -> STS -> Sync -> Metrics

**Principle VIII - Test-First Development (NON-NEGOTIABLE)**:
- [x] Test strategy defined for all user stories (see Test Strategy section)
- [x] Mock patterns documented for GStreamer and STS
- [x] Coverage targets: 80% minimum, 95% for critical paths (A/V sync, STS)
- [x] Test infrastructure: pytest, pytest-cov with coverage enforcement
- [x] Test organization: `apps/media-service/tests/{unit,integration}`

## Project Structure

### Documentation (this feature)

```text
specs/003-gstreamer-stream-worker/
├── plan.md              # This file
├── spec.md              # Feature specification
├── checklists/
│   └── requirements.md  # Specification quality checklist
├── data-model.md        # Data structures (AudioChunk, StsRequest, etc.)
├── quickstart.md        # Developer quick start guide
├── contracts/           # API contracts
│   ├── sts-api.json     # STS Service API contract
│   └── metrics.md       # Prometheus metrics contract
└── tasks.md             # Implementation tasks (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
apps/media-service/
├── src/
│   └── media_service/
│       ├── __init__.py
│       ├── worker/
│       │   ├── __init__.py
│       │   ├── stream_worker.py      # Existing (extend)
│       │   └── worker_runner.py      # New: async worker lifecycle
│       ├── pipeline/                  # New: GStreamer pipelines
│       │   ├── __init__.py
│       │   ├── input.py              # RTSP input pipeline
│       │   ├── output.py             # RTMP output pipeline
│       │   └── elements.py           # Shared element builders
│       ├── buffer/                    # New: Segment buffering
│       │   ├── __init__.py
│       │   └── segment_buffer.py     # 6-second segment accumulator
│       ├── audio/                     # New: Audio processing
│       │   ├── __init__.py
│       │   └── segment_writer.py     # M4A segment writer
│       ├── video/                     # New: Video processing
│       │   ├── __init__.py
│       │   └── segment_writer.py     # MP4 segment writer
│       ├── sts/                       # New: STS Socket.IO integration
│       │   ├── __init__.py
│       │   ├── socketio_client.py    # Socket.IO AsyncClient for STS
│       │   ├── fragment_tracker.py   # In-flight fragment tracking
│       │   ├── backpressure_handler.py  # Backpressure flow control
│       │   ├── reconnection_manager.py  # Exponential backoff reconnection
│       │   ├── circuit_breaker.py    # Circuit breaker with error filtering
│       │   └── models.py             # Data models (StreamConfig, etc.)
│       ├── sync/                      # New: A/V synchronization
│       │   ├── __init__.py
│       │   └── av_sync.py            # PTS management
│       └── metrics/                   # New: Observability
│           ├── __init__.py
│           └── prometheus.py         # Metric definitions
├── tests/
│   ├── unit/
│   │   ├── test_stream_worker.py     # Existing
│   │   ├── test_input_pipeline.py    # New
│   │   ├── test_output_pipeline.py   # New
│   │   ├── test_segment_buffer.py    # New
│   │   ├── test_audio_segment_writer.py  # New
│   │   ├── test_video_segment_writer.py  # New
│   │   ├── test_sts_socketio_client.py   # New: Socket.IO client tests
│   │   ├── test_fragment_tracker.py      # New
│   │   ├── test_backpressure_handler.py  # New
│   │   ├── test_reconnection_manager.py  # New
│   │   ├── test_circuit_breaker.py   # New
│   │   ├── test_av_sync.py           # New
│   │   └── test_prometheus.py        # New
│   └── integration/
│       ├── test_pipeline_passthrough.py  # New
│       ├── test_segment_pipeline.py      # New: segment buffering
│       ├── test_sts_socketio_echo.py     # New: with Echo STS Service
│       └── conftest.py               # Fixtures for MediaMTX + Echo STS + 1-min-nfl.mp4
└── pyproject.toml

tests/fixtures/test-streams/
├── 1-min-nfl.mp4                     # Exists: 60s H.264 1280x720 30fps + AAC 44.1kHz stereo
├── ffmpeg-publish.sh                 # Publish fixture to MediaMTX
└── gstreamer-publish.sh              # Alternative GStreamer publish
```

**Structure Decision**: Extends existing `apps/media-service` with new subpackages for GStreamer pipelines (`pipeline/`), segment buffering (`buffer/`), audio/video segment writers (`audio/`, `video/`), STS Socket.IO integration (`sts/`), synchronization (`sync/`), and metrics (`metrics/`).

## Implementation Phases

### Phase 1: GStreamer Pipeline Foundation (P1)

**Goal**: Establish input/output pipelines for RTSP-to-RTMP passthrough.

**Modules**:
1. `pipeline/input.py` - RTSP input pipeline with video/audio appsinks
2. `pipeline/output.py` - RTMP output pipeline with video/audio appsrcs
3. `pipeline/elements.py` - Shared element builders (rtspsrc, flvmux, etc.)

**Key Decisions**:
- Use `rtspsrc protocols=tcp latency=200` for reliable RTSP
- Demux to separate appsinks: video (H.264), audio (decode to PCM S16LE @ 48kHz)
- Output uses `appsrc is-live=true format=time do-timestamp=false`
- Video codec-copied (no re-encode), audio encoded to AAC 128kbps

**Tests**:
- Unit: `test_build_input_pipeline()`, `test_build_output_pipeline()`
- Unit: `test_appsink_callback_receives_buffers()`
- Contract: `test_rtsp_input_url_format()` (already exists)
- Integration: `test_worker_passthrough_1min_nfl()` with MediaMTX + test fixture

**Success Criteria**:
- Pipeline starts and processes 60s fixture without errors
- Video codec remains H.264 (verified by ffprobe)
- Audio output duration matches input (+/- 100ms)

### Phase 2: Segment Buffering and Storage (P1)

**Goal**: Implement segment buffering for both video (MP4) and audio (M4A) tracks.

**Modules**:
1. `audio/segment_writer.py` - Write audio segments to M4A files
2. `video/segment_writer.py` - Write video segments to MP4 files
3. `buffer/segment_buffer.py` - Accumulate 6-second segments for both tracks

**Key Decisions**:
- Buffer accumulates 6 seconds of video and audio separately (configurable via WORKER_SEGMENT_DURATION)
- Video segments written as MP4 (H.264 codec-copy)
- Audio segments written as M4A (AAC codec-copy in MP4 container)
- Segment naming: `{stream_id}/{batch_number:06d}_{video|audio}.{mp4|m4a}`
- Each segment includes: fragment_id (UUID), stream_id, batch_number, t0_ns, duration_ns, file_path

**Data Structures**:
- `VideoSegment`: Video segment metadata (fragment_id, batch_number, t0_ns, duration_ns, file_path)
- `AudioSegment`: Audio segment metadata (fragment_id, batch_number, t0_ns, duration_ns, file_path)

**Tests**:
- Unit: `test_demuxer_separates_tracks()` validates FLV demux produces video and audio streams
- Unit: `test_buffer_accumulates_6s()` validates 6-second buffering for both tracks
- Unit: `test_video_segment_writer()` validates MP4 output with H.264 codec-copy
- Unit: `test_audio_segment_writer()` validates M4A output with AAC codec-copy
- Integration: `test_segment_pipeline_1min_nfl()` validates 10 segments from 60s fixture

**Success Criteria**:
- Segments are exactly 6s (+/- 100ms)
- MP4/M4A formats are valid (ffprobe verification)
- Timestamps preserved correctly
- Partial segments written on EOS

### Phase 3: STS Socket.IO Client Integration (P1)

**Goal**: Implement real-time STS communication via Socket.IO using the WebSocket Audio Fragment Protocol (spec 017).

**Modules**:
1. `sts/socketio_client.py` - Socket.IO AsyncClient for STS Service
2. `sts/fragment_tracker.py` - Track in-flight fragments and timeouts
3. `sts/backpressure_handler.py` - Handle backpressure events and flow control
4. `sts/reconnection_manager.py` - Manage reconnection with exponential backoff

**Key Decisions**:
- Use `socketio.AsyncClient` with WebSocket transport only (`transports=['websocket']`)
- Connection headers: `X-Stream-ID` and `X-Worker-ID` via `extra_headers` parameter
- Reconnection: 5 attempts with exponential backoff (2s, 4s, 8s, 16s, 32s) - custom implementation
- In-flight tracking: Map of fragment_id -> (AudioSegment, sent_time, timeout_task)
- Backpressure handling:
  - `slow_down`: Insert `recommended_delay_ms` wait before each fragment send
  - `pause`: Stop sending until `action: none` received
  - `none`: Resume normal sending rate
- Fragment timeout: WORKER_STS_TIMEOUT_MS (default 8000ms) per fragment

**Socket.IO Event Flow**:
```
Worker                              STS Service
  |                                      |
  |-- connect (X-Stream-ID header) ----->|
  |<---- (connection established) -------|
  |                                      |
  |-- stream:init ---------------------->|
  |   {stream_id, worker_id, config,     |
  |    max_inflight: 3, timeout_ms: 8000}|
  |                                      |
  |<---- stream:ready -------------------|
  |   {session_id, max_inflight,         |
  |    capabilities}                     |
  |                                      |
  |== Fragment Loop ====================|
  |                                      |
  |-- fragment:data -------------------->|
  |   {fragment_id, stream_id,           |
  |    sequence_number, timestamp,       |
  |    audio: {format: "m4a",            |
  |            data_base64, ...}}        |
  |                                      |
  |<---- fragment:ack -------------------|
  |   {fragment_id, status: "queued"}    |
  |                                      |
  |<---- fragment:processed -------------|
  |   {fragment_id, status: "success",   |
  |    dubbed_audio: {data_base64, ...}} |
  |                                      |
  |-- fragment:ack -------------------->|
  |   {fragment_id, status: "applied"}   |
  |                                      |
  |== Backpressure (optional) ==========|
  |                                      |
  |<---- backpressure -------------------|
  |   {action: "slow_down",              |
  |    recommended_delay_ms: 500}        |
  |                                      |
  |== Stream End =======================|
  |                                      |
  |-- stream:end ----------------------->|
  |                                      |
  |<---- stream:complete ----------------|
  |   {total_fragments, statistics}      |
  |                                      |
  |-- disconnect ----------------------->|
```

**StsSocketIOClient Class Design**:
```python
class StsSocketIOClient:
    """Socket.IO client for STS Service communication."""

    def __init__(
        self,
        url: str,
        stream_id: str,
        worker_id: str,
        config: StreamConfig,
        max_inflight: int = 3,
        timeout_ms: int = 8000,
        max_reconnect_attempts: int = 5,
    ):
        self._sio = socketio.AsyncClient(
            reconnection=False,  # Custom reconnection logic
        )
        self._url = url
        self._stream_id = stream_id
        self._worker_id = worker_id
        self._config = config
        self._max_inflight = max_inflight
        self._timeout_ms = timeout_ms
        self._max_reconnect_attempts = max_reconnect_attempts

        # State
        self._session_id: str | None = None
        self._sequence_number: int = 0
        self._inflight: dict[str, InFlightFragment] = {}
        self._backpressure_delay_ms: int = 0
        self._paused: bool = False
        self._connected: bool = False
        self._reconnect_count: int = 0

        # Callbacks
        self._on_dubbed_audio: Callable[[str, bytes], Awaitable[None]] | None = None
        self._on_fallback: Callable[[str], Awaitable[None]] | None = None

        # Register event handlers
        self._register_handlers()

    async def connect(self) -> None:
        """Connect to STS Service with extra headers."""
        await self._sio.connect(
            self._url,
            transports=['websocket'],
            headers={
                'X-Stream-ID': self._stream_id,
                'X-Worker-ID': self._worker_id,
            },
        )
        self._connected = True
        await self._init_stream()

    async def send_fragment(self, segment: AudioSegment) -> None:
        """Send audio fragment for processing."""
        if self._paused:
            return  # Skip if paused by backpressure

        # Apply backpressure delay if active
        if self._backpressure_delay_ms > 0:
            await asyncio.sleep(self._backpressure_delay_ms / 1000)

        # Respect max_inflight
        while len(self._inflight) >= self._max_inflight:
            await asyncio.sleep(0.1)

        fragment_id = segment.fragment_id
        audio_data = await self._read_m4a_file(segment.file_path)

        payload = {
            'fragment_id': fragment_id,
            'stream_id': self._stream_id,
            'sequence_number': self._sequence_number,
            'timestamp': int(time.time() * 1000),
            'audio': {
                'format': 'm4a',
                'sample_rate_hz': 48000,
                'channels': 2,
                'duration_ms': segment.duration_ns // 1_000_000,
                'data_base64': base64.b64encode(audio_data).decode(),
            },
            'metadata': {
                'pts_ns': segment.t0_ns,
            },
        }

        await self._sio.emit('fragment:data', payload)
        self._inflight[fragment_id] = InFlightFragment(
            segment=segment,
            sent_time=time.monotonic(),
            sequence_number=self._sequence_number,
        )
        self._sequence_number += 1

        # Start timeout task
        asyncio.create_task(self._fragment_timeout(fragment_id))

    async def _handle_disconnect(self, reason: str) -> None:
        """Handle unexpected disconnect with reconnection."""
        self._connected = False

        # Fallback all in-flight fragments
        for fragment_id in list(self._inflight.keys()):
            if self._on_fallback:
                await self._on_fallback(fragment_id)
            del self._inflight[fragment_id]

        # Attempt reconnection with exponential backoff
        backoff_delays = [2, 4, 8, 16, 32]  # seconds
        while self._reconnect_count < self._max_reconnect_attempts:
            delay = backoff_delays[self._reconnect_count]
            await asyncio.sleep(delay)
            self._reconnect_count += 1
            try:
                await self.connect()
                self._reconnect_count = 0  # Reset on success
                self._sequence_number = 0  # Fresh sequence after reconnect
                return
            except Exception:
                continue

        # Permanent failure after max attempts
        raise StsConnectionError("Max reconnection attempts exceeded")
```

**Data Structures**:
```python
@dataclass
class StreamConfig:
    source_language: str = "en"
    target_language: str = "es"
    voice_profile: str = "default"
    format: str = "m4a"
    sample_rate_hz: int = 48000
    channels: int = 2

@dataclass
class InFlightFragment:
    segment: AudioSegment
    sent_time: float  # monotonic time
    sequence_number: int
    timeout_task: asyncio.Task | None = None

@dataclass
class FragmentProcessedEvent:
    fragment_id: str
    stream_id: str
    sequence_number: int
    status: Literal["success", "partial", "failed"]
    dubbed_audio: AudioData | None
    transcript: str | None
    translated_text: str | None
    processing_time_ms: int
    error: ProcessingError | None

@dataclass
class BackpressureEvent:
    stream_id: str
    severity: Literal["low", "medium", "high"]
    current_inflight: int
    queue_depth: int
    action: Literal["slow_down", "pause", "none"]
    recommended_delay_ms: int = 0
```

**Tests**:
- Unit: `test_sts_client_connects()` validates Socket.IO connection with extra headers
- Unit: `test_sts_client_stream_init()` validates stream:init emission and stream:ready reception
- Unit: `test_sts_client_sends_fragment()` validates fragment:data emission with M4A audio
- Unit: `test_sts_client_receives_ack()` validates fragment:ack reception
- Unit: `test_sts_client_receives_dubbed()` validates fragment:processed reception
- Unit: `test_sts_client_handles_backpressure_slowdown()` validates recommended_delay_ms applied
- Unit: `test_sts_client_handles_backpressure_pause()` validates pause/resume flow
- Unit: `test_sts_client_reconnect_max_attempts()` validates 5 attempts with exponential backoff
- Unit: `test_sts_client_inflight_discard_on_reconnect()` validates fallback for in-flight fragments
- Unit: `test_sts_client_respects_max_inflight()` validates max_inflight limit
- Unit: `test_sts_client_fragment_timeout()` validates timeout triggers fallback
- Contract: `test_sts_socketio_events()` validates event names and payload schemas per spec 017
- Integration: `test_sts_client_with_echo_service()` validates full round-trip with Echo STS

**Success Criteria**:
- Connection established with correct headers
- Stream lifecycle managed (init -> ready -> fragments -> end -> complete)
- Fragments sent with correct schema (m4a format)
- Backpressure actions respected (slow_down inserts delay, pause stops sending)
- Reconnection works with exponential backoff (2s, 4s, 8s, 16s, 32s)
- In-flight fragments fallback to original audio on disconnect
- Fragment timeout triggers fallback after 8000ms

### Phase 4: A/V Sync Mechanism (P2)

**Goal**: Maintain audio/video synchronization with configurable offset.

**Modules**:
1. `sync/av_sync.py` - PTS management with offset and drift correction

**Key Decisions**:
- Default av_offset_ns = 6_000_000_000 (6 seconds) for STS processing buffer
- Video PTS adjusted by av_offset_ns before output
- Audio PTS tracked independently, adjusted after STS processing
- Drift correction uses gradual slew (not hard jumps)

**Tests**:
- Unit: `test_av_offset_calculation()`
- Unit: `test_pts_adjustment_video()`
- Unit: `test_pts_adjustment_audio()`
- Unit: `test_drift_detection()`
- Integration: `test_av_sync_within_threshold()` with 1-min-nfl.mp4

**Success Criteria**:
- Initial av_offset_ns equals 6_000_000_000
- A/V sync delta remains < 120ms steady-state
- Metric av_sync_delta_ms reflects actual delta

### Phase 5: Circuit Breaker and Resilience (P2)

**Goal**: Protect against STS failures with automatic recovery.

**Modules**:
1. `sts/circuit_breaker.py` - Circuit breaker state machine wrapper

**Key Decisions**:
- States: closed (normal), half_open (probing), open (fallback)
- Opens after 5 consecutive STS failures with **retryable errors only**
- Retryable errors: TIMEOUT, MODEL_ERROR, GPU_OOM, QUEUE_FULL, RATE_LIMIT
- Non-retryable errors (STREAM_NOT_FOUND, INVALID_CONFIG, FRAGMENT_TOO_LARGE, INVALID_SEQUENCE) do NOT increment failure counter
- Enters half_open after 30s cooldown
- Closes on successful probe in half_open
- While open, skip STS calls and use original audio (passthrough fallback)

**Error Classification**:
```python
RETRYABLE_ERRORS = {
    "TIMEOUT",
    "MODEL_ERROR",
    "GPU_OOM",
    "QUEUE_FULL",
    "RATE_LIMIT",
}

NON_RETRYABLE_ERRORS = {
    "STREAM_NOT_FOUND",
    "INVALID_CONFIG",
    "FRAGMENT_TOO_LARGE",
    "INVALID_SEQUENCE",
}
```

**Tests**:
- Unit: `test_circuit_breaker_opens_after_failures()` validates breaker opens after 5 retryable errors
- Unit: `test_circuit_breaker_ignores_non_retryable()` validates non-retryable errors do not increment counter
- Unit: `test_circuit_breaker_half_open()` validates cooldown and probe behavior
- Unit: `test_circuit_breaker_closes_on_success()` validates recovery
- Unit: `test_fallback_audio_used_when_open()` validates fallback audio used
- Integration: `test_circuit_breaker_recovery_cycle()` with Echo STS error simulation

**Success Criteria**:
- Breaker opens after 5 consecutive retryable failures
- Non-retryable errors do NOT increment failure counter
- Breaker enters half_open after 30s cooldown
- Breaker closes on successful probe
- Stream continues with fallback audio when breaker open

### Phase 6: Prometheus Metrics (P3)

**Goal**: Expose observability metrics for production operations.

**Modules**:
1. `metrics/prometheus.py` - Metric definitions and endpoint

**Metrics to Implement**:
| Metric Name | Type | Description |
|-------------|------|-------------|
| `worker_audio_fragments_total` | Counter | Total audio fragments processed |
| `worker_fallback_total` | Counter | Total fallback activations |
| `worker_gst_bus_errors_total` | Counter | GStreamer bus errors |
| `worker_inflight_fragments` | Gauge | Currently in-flight fragments |
| `worker_av_sync_delta_ms` | Gauge | Current A/V sync delta in ms |
| `worker_sts_breaker_state` | Gauge | 0=closed, 1=half_open, 2=open |
| `worker_sts_rtt_ms` | Histogram | STS round-trip time histogram |

**Tests**:
- Unit: `test_metrics_endpoint_returns_prometheus_format()`
- Unit: `test_counter_increments()`
- Unit: `test_gauge_updates()`
- Unit: `test_histogram_buckets()`

**Success Criteria**:
- GET /metrics returns Prometheus text format
- All required metrics exposed with correct types
- Metrics update in real-time during processing

## Integration Strategy

### Extending StreamWorker

The existing `StreamWorker` class provides:
- URL generation (`get_rtsp_input_url()`, `get_rtmp_output_url()`)
- Stream ID validation
- Retry logic with exponential backoff
- State management (idle, connecting, running, stopped)

**Extension Approach**:

1. **Create `WorkerRunner`**: New async class that orchestrates the full pipeline
   ```python
   class WorkerRunner:
       def __init__(
           self,
           worker: StreamWorker,
           sts_url: str,
           stream_config: StreamConfig,
       ):
           self.worker = worker
           self.input_pipeline: InputPipeline | None = None
           self.output_pipeline: OutputPipeline | None = None
           self.segment_buffer = SegmentBuffer(duration_s=6)
           self.av_sync = AvSync()
           self.circuit_breaker = CircuitBreaker()

           # STS Socket.IO client
           self.sts_client = StsSocketIOClient(
               url=sts_url,
               stream_id=worker.stream_id,
               worker_id=worker.worker_id,
               config=stream_config,
               max_inflight=3,
               timeout_ms=8000,
               max_reconnect_attempts=5,
           )
           self.sts_client.on_dubbed_audio = self._handle_dubbed_audio
           self.sts_client.on_fallback = self._handle_fallback
   ```

2. **Compose Pipelines**: `WorkerRunner` creates and links input/output pipelines
   ```python
   async def start(self):
       # Connect to STS Service via Socket.IO first
       await self.sts_client.connect()

       self.input_pipeline = InputPipeline(
           rtsp_url=self.worker.get_rtsp_input_url(),
           on_video_buffer=self._handle_video,
           on_audio_buffer=self._handle_audio,
       )
       self.output_pipeline = OutputPipeline(
           rtmp_url=self.worker.get_rtmp_output_url(),
       )
   ```

3. **Wire Segment Processing**: Buffer -> Segment Writer -> STS Socket.IO -> Output
   ```python
   async def _handle_audio(self, buffer: Gst.Buffer):
       segment = self.segment_buffer.push_audio(buffer)
       if segment:
           # Write M4A segment to disk
           await self.audio_writer.write(segment)

           if self.circuit_breaker.is_closed():
               # Send via Socket.IO (non-blocking)
               await self.sts_client.send_fragment(segment)
           else:
               # Circuit breaker open - use original audio
               await self._handle_fallback(segment.fragment_id)

   async def _handle_dubbed_audio(self, fragment_id: str, dubbed_m4a: bytes):
       """Callback when fragment:processed received with status success."""
       # Decode M4A and queue for remuxing
       segment = self._get_segment(fragment_id)
       await self.output_pipeline.push_audio(dubbed_m4a, segment.t0_ns)

   async def _handle_fallback(self, fragment_id: str):
       """Callback for timeout or circuit breaker fallback."""
       segment = self._get_segment(fragment_id)
       original_m4a = await self._read_m4a_file(segment.file_path)
       await self.output_pipeline.push_audio(original_m4a, segment.t0_ns)
   ```

4. **Preserve Existing Interface**: `StreamWorker` remains the entry point
   ```python
   async def run(worker: StreamWorker):
       runner = WorkerRunner(
           worker,
           sts_url=os.getenv("WORKER_STS_SERVICE_URL"),
           stream_config=StreamConfig(
               source_language="en",
               target_language="es",
           ),
       )
       await runner.start()
   ```

## Test Strategy with 1-min-nfl.mp4

### Test Fixture Details

**File**: `tests/fixtures/test-streams/1-min-nfl.mp4`
**Duration**: 60.091 seconds
**Video**: H.264 High Profile, 1280x720, 30fps, ~2.2 Mbps
**Audio**: AAC LC, 44.1kHz stereo, ~128 kbps

**Note**: Spec requires 48kHz for STS processing. Audio will be resampled in pipeline.

### Unit Tests (Mocked GStreamer)

For unit tests, GStreamer elements are mocked to avoid requiring the full multimedia stack:

```python
# conftest.py
@pytest.fixture
def mock_gst():
    """Mock GStreamer for unit tests."""
    with patch('gi.repository.Gst') as mock:
        mock.Buffer = MagicMock()
        mock.Pipeline = MagicMock()
        yield mock
```

Unit test examples:
- `test_build_input_pipeline()`: Verify pipeline string construction
- `test_appsink_configuration()`: Verify caps and callback setup
- `test_chunker_with_synthetic_pcm()`: Feed 20ms PCM buffers, verify 1s chunks

### Integration Tests (Real Pipeline + Test Fixture + Echo STS)

Integration tests require Docker Compose with MediaMTX and Echo STS Service:

```python
# conftest.py
import pytest
import subprocess
import asyncio

@pytest.fixture(scope="session")
def docker_services():
    """Start MediaMTX and Echo STS containers for integration tests."""
    # Uses existing docker-compose.yml with both services
    subprocess.run([
        "docker-compose", "-f", "apps/media-service/docker-compose.yml",
        "up", "-d", "mediamtx", "echo-sts"
    ], check=True)
    # Wait for services to be ready
    import time
    time.sleep(3)
    yield
    subprocess.run([
        "docker-compose", "-f", "apps/media-service/docker-compose.yml",
        "down"
    ])

@pytest.fixture
def publish_test_stream(docker_services):
    """Publish 1-min-nfl.mp4 to MediaMTX."""
    proc = subprocess.Popen([
        "ffmpeg", "-re", "-stream_loop", "-1",
        "-i", "tests/fixtures/test-streams/1-min-nfl.mp4",
        "-c", "copy", "-f", "rtmp",
        "rtmp://localhost:1935/live/test/in"
    ])
    yield
    proc.terminate()

@pytest.fixture
def echo_sts_url():
    """Return Echo STS Service URL."""
    return "http://localhost:8080"

@pytest.fixture
async def sts_client(echo_sts_url):
    """Create and connect STS Socket.IO client."""
    from media_service.sts.socketio_client import StsSocketIOClient
    from media_service.sts.models import StreamConfig

    client = StsSocketIOClient(
        url=echo_sts_url,
        stream_id="test-stream",
        worker_id="test-worker",
        config=StreamConfig(source_language="en", target_language="es"),
    )
    await client.connect()
    yield client
    await client.disconnect()
```

Integration test examples:
- `test_worker_passthrough_1min_nfl()`: Full passthrough, verify output
- `test_segment_pipeline_real_stream()`: Real segment buffering from fixture (10x 6s segments)
- `test_sts_socketio_echo_round_trip()`: Full Socket.IO round-trip with Echo STS Service
- `test_sts_socketio_backpressure()`: Backpressure handling with Echo STS error simulation
- `test_sts_socketio_reconnection()`: Reconnection with exponential backoff

### Coverage Requirements

| Module | Minimum Coverage | Rationale |
|--------|------------------|-----------|
| `sts/socketio_client.py` | 95% | Critical path for real-time STS communication |
| `sts/fragment_tracker.py` | 95% | In-flight tracking critical for fallback |
| `sts/backpressure_handler.py` | 95% | Flow control critical for stability |
| `sts/reconnection_manager.py` | 95% | Reconnection critical for reliability |
| `sync/av_sync.py` | 95% | Critical for user experience |
| `buffer/segment_buffer.py` | 90% | Segment timing critical |
| `audio/segment_writer.py` | 90% | M4A output integrity |
| `video/segment_writer.py` | 90% | MP4 output integrity |
| `sts/circuit_breaker.py` | 90% | Resilience logic |
| `pipeline/input.py` | 80% | GStreamer callbacks hard to mock |
| `pipeline/output.py` | 80% | GStreamer callbacks hard to mock |
| `metrics/prometheus.py` | 80% | Observability |

## Data Model

See `data-model.md` for complete definitions. Key structures:

### VideoSegment

```python
@dataclass
class VideoSegment:
    fragment_id: str          # UUID for this segment
    stream_id: str            # Stream identifier
    batch_number: int         # Sequential batch number
    t0_ns: int                # Timestamp of first frame (nanoseconds)
    duration_ns: int          # Duration in nanoseconds
    file_path: Path           # Path to MP4 file on disk
```

### AudioSegment

```python
@dataclass
class AudioSegment:
    fragment_id: str          # UUID for this segment
    stream_id: str            # Stream identifier
    batch_number: int         # Sequential batch number
    t0_ns: int                # Timestamp of first sample (nanoseconds)
    duration_ns: int          # Duration in nanoseconds
    file_path: Path           # Path to M4A file on disk
```

### StreamConfig (Socket.IO)

```python
@dataclass
class StreamConfig:
    source_language: str = "en"
    target_language: str = "es"
    voice_profile: str = "default"
    format: str = "m4a"
    sample_rate_hz: int = 48000
    channels: int = 2
    chunk_duration_ms: int = 6000
```

### InFlightFragment

```python
@dataclass
class InFlightFragment:
    segment: AudioSegment       # Reference to original segment
    sent_time: float            # Monotonic time when sent
    sequence_number: int        # Socket.IO sequence number
    timeout_task: asyncio.Task | None = None
```

### FragmentDataPayload (Socket.IO emit)

```python
@dataclass
class FragmentDataPayload:
    fragment_id: str            # UUID from AudioSegment
    stream_id: str              # Stream identifier
    sequence_number: int        # 0-based monotonic
    timestamp: int              # Unix timestamp in milliseconds
    audio: AudioData            # Audio object with data_base64
    metadata: FragmentMetadata | None = None
```

### AudioData

```python
@dataclass
class AudioData:
    format: str                 # "m4a"
    sample_rate_hz: int         # 48000
    channels: int               # 1 or 2
    duration_ms: int            # Segment duration
    data_base64: str            # Base64-encoded M4A data
```

### FragmentProcessedPayload (Socket.IO receive)

```python
@dataclass
class FragmentProcessedPayload:
    fragment_id: str            # Original fragment UUID
    stream_id: str              # Stream identifier
    sequence_number: int        # Original sequence number
    status: Literal["success", "partial", "failed"]
    dubbed_audio: AudioData | None  # Dubbed audio if success/partial
    transcript: str | None      # ASR output
    translated_text: str | None # Translation output
    processing_time_ms: int     # Server processing time
    stage_timings: StageTimings | None
    error: ProcessingError | None
```

### BackpressurePayload (Socket.IO receive)

```python
@dataclass
class BackpressurePayload:
    stream_id: str
    severity: Literal["low", "medium", "high"]
    current_inflight: int
    queue_depth: int
    action: Literal["slow_down", "pause", "none"]
    recommended_delay_ms: int = 0
```

### CircuitBreaker

```python
@dataclass
class CircuitBreaker:
    state: Literal["closed", "half_open", "open"]
    failure_count: int
    last_failure_time: float
    cooldown_seconds: float = 30.0
    failure_threshold: int = 5

    # Error classification for failure counting
    RETRYABLE_ERRORS: ClassVar[set[str]] = {
        "TIMEOUT", "MODEL_ERROR", "GPU_OOM", "QUEUE_FULL", "RATE_LIMIT"
    }
```

## Complexity Tracking

No constitution violations identified. The design follows all principles:
- Single worker per stream (Principle VII incremental)
- Mocked testing without live endpoints (Principle II)
- Tests before implementation (Principle VIII)

## Dependencies

### Python Packages (add to pyproject.toml)

```toml
dependencies = [
    # Existing...
    "PyGObject>=3.44.0",          # GStreamer bindings
    "python-socketio[asyncio]>=5.0",  # Socket.IO AsyncClient
    "prometheus_client>=0.19.0",  # Metrics
]
```

### System Dependencies (Dockerfile)

```dockerfile
RUN apt-get update && apt-get install -y \
    gstreamer1.0-tools \
    gstreamer1.0-plugins-base \
    gstreamer1.0-plugins-good \
    gstreamer1.0-plugins-bad \
    gstreamer1.0-plugins-ugly \
    gstreamer1.0-libav \
    python3-gi \
    gir1.2-gst-plugins-base-1.0
```

## Next Steps

1. Run `/speckit.tasks` to generate implementation tasks
2. Begin Phase 1 with TDD: write failing tests for input pipeline
3. Implement GStreamer pipeline elements
4. Validate with 1-min-nfl.mp4 passthrough test
5. Begin Phase 2: Segment buffering (MP4/M4A writers)
6. Begin Phase 3: STS Socket.IO client with Echo STS integration tests
7. Validate full round-trip: segment -> Socket.IO -> dubbed audio -> output

## Clarifications Applied

The following clarifications from spec.md Session 2025-12-29 have been incorporated:

1. **Reconnection attempts**: 5 attempts with exponential backoff (2s, 4s, 8s, 16s, 32s) - implemented in `StsSocketIOClient._handle_disconnect()`
2. **In-flight fragment handling on reconnect**: Discard in-flight fragments (fallback to original audio), resume with next new segment using fresh sequence numbering
3. **Backpressure slow_down action**: Insert `recommended_delay_ms` wait before sending each new fragment - implemented in `send_fragment()` method
4. **Circuit breaker error filtering**: Only retryable errors (TIMEOUT, MODEL_ERROR, GPU_OOM, QUEUE_FULL, RATE_LIMIT) increment failure counter; non-retryable errors are logged but do not affect breaker state
